---
title: "Example 10: Care Home Staffing Investigation"
subtitle: "Outlier Detection and Treatment with Data Quality Issues"
number-sections: false
---

```{r}
#| include: false
library(reticulate)
use_python("C:/Users/fede/anaconda3/python.exe", required = TRUE)
```

## Scenario Overview

**Method**: Outlier Detection and Treatment (@sec-outlier-methods)  
**Complexity**: Medium  
**Time to complete**: 2-3 hours  
**Status**: ‚úÖ Complete

::: {.callout-note icon=false}
## üìñ Method Reference
For detailed explanation of outlier detection methods, treatment strategies, and step-by-step guidance, see @sec-outlier-methods.
:::

---

## üìã Scenario

You are a CQC analyst investigating staffing levels at adult social care homes. Recent submissions show some extreme staff-to-resident ratios that warrant investigation. The analysis will support:

- Identifying homes requiring immediate inspection (data errors vs genuine understaffing)
- Understanding natural variation in staffing models
- Informing risk-based targeting

**Analytical Question**: Which care homes have staffing ratios extreme enough to warrant investigation, and which extreme values are data errors versus genuine operational issues?

**Context**: Care homes report monthly staffing data. Most homes have 2-4 qualified staff per 10 residents, but you've seen values ranging from 0 to 12. Some may be data entry errors (wrong decimal point, missing zeros), others may reflect genuine operational models (specialist dementia units) or problems (understaffing due to recruitment issues).

---

## üéØ Learning Objectives

By working through this example, you will learn to:

1. **Visualize data** to understand distribution before detection
2. **Apply multiple detection methods** (Z-score, Modified Z-score, IQR)
3. **Compare method results** to prioritize investigation
4. **Investigate flagged observations** systematically
5. **Distinguish data errors from genuine extremes**
6. **Document outlier treatment decisions** for QA purposes
7. **Communicate findings** to inspection teams
8. **Handle small provider variation** appropriately

---

## üìä Dataset Description

### Synthetic Data: Generated for this example

**350 care homes** with the following variables:

| Variable | Description | Type | Notes |
|----------|-------------|------|-------|
| `home_id` | Unique home identifier | String | Format: CH001-CH350 |
| `home_name` | Care home name | String | Synthetic names |
| `region` | NHS England region | String | 7 regions |
| `beds` | Number of beds | Integer | 15-120 beds |
| `care_type` | Specialization | String | General, Dementia, Nursing |
| `cqc_rating` | Current CQC rating | String | Outstanding to Inadequate |
| `staff_per_10` | Qualified staff per 10 residents | Numeric | Ratio (target 2.5-4.0) |

### Data Characteristics

**Realistic issues included**:
- Most homes (300): Normal staffing (mean 3.2, SD 0.8)
- Specialist dementia units (15): Higher staffing (mean 5.5)
- Struggling homes (10): Low staffing (mean 1.5)
- Data entry errors (12): Implausible values (0, 0.02, 9.8, 11.2, etc.)
- Small homes: Higher natural variation
- Regional differences

---

## üîç Step 1: Load and Explore Data

::: {.panel-tabset}
## R
```{r}
#| eval: true
set.seed(456)
suppressPackageStartupMessages({
  library(ggplot2)
})
# Use base R for data manipulation (no dplyr dependency)

# Generate realistic care home data
n_normal <- 300
n_specialist <- 15
n_struggling <- 10
n_errors <- 12
n_total <- n_normal + n_specialist + n_struggling + n_errors

care_homes <- data.frame(
  home_id = sprintf("CH%03d", 1:n_total),
  home_name = paste("Care Home", 1:n_total),
  region = sample(c("London", "South East", "North West", "Midlands", 
                    "South West", "North East", "East"), n_total, replace = TRUE),
  beds = sample(15:120, n_total, replace = TRUE),
  care_type = sample(c("General", "Dementia", "Nursing"), n_total, 
                     replace = TRUE, prob = c(0.6, 0.2, 0.2)),
  cqc_rating = sample(c("Outstanding", "Good", "Requires Improvement", "Inadequate"),
                      n_total, replace = TRUE, prob = c(0.05, 0.7, 0.2, 0.05)),
  staff_per_10 = c(
    rnorm(n_normal, mean = 3.2, sd = 0.8),
    rnorm(n_specialist, mean = 5.5, sd = 0.4),
    rnorm(n_struggling, mean = 1.5, sd = 0.3),
    c(0, 0.02, 0.05, 9.8, 10.5, 11.2, -0.3, 0.1, 8.5, 7.9, 6.8, 12.0)
  )
)

care_homes$staff_per_10 <- pmax(care_homes$staff_per_10, 0)

small_homes <- care_homes$beds < 30
care_homes$staff_per_10[small_homes] <- care_homes$staff_per_10[small_homes] + 
                                        rnorm(sum(small_homes), 0, 0.3)

cat("=== CARE HOME STAFFING DATA ===\n\n")
cat("Total homes:", nrow(care_homes), "\n")
summary(care_homes$staff_per_10)
```

## Python
```{python}
#| eval: true
import pandas as pd
import numpy as np

care_homes = pd.DataFrame({
    'home_id': r.care_homes['home_id'],
    'home_name': r.care_homes['home_name'],
    'region': r.care_homes['region'],
    'beds': r.care_homes['beds'],
    'care_type': r.care_homes['care_type'],
    'cqc_rating': r.care_homes['cqc_rating'],
    'staff_per_10': r.care_homes['staff_per_10']
})

print("=== CARE HOME STAFFING DATA ===\n")
print(f"Total homes: {len(care_homes)}\n")
print(care_homes['staff_per_10'].describe())
```
:::

---

## üîç Step 2: Visualize Distribution

::: {.panel-tabset}
## R
```{r}
#| eval: true
#| fig-width: 14
#| fig-height: 5

suppressPackageStartupMessages(library(gridExtra))

p1 <- ggplot(care_homes, aes(x = staff_per_10)) +
  geom_histogram(aes(y = after_stat(density)), bins = 40, 
                 fill = "lightblue", alpha = 0.7, color = "black") +
  geom_density(color = "darkblue", linewidth = 1.2) +
  labs(title = "Distribution of Staffing Ratios",
       x = "Staff per 10 Residents", y = "Density") +
  theme_minimal()

p2 <- ggplot(care_homes, aes(y = staff_per_10)) +
  geom_boxplot(fill = "lightblue", outlier.color = "red", outlier.size = 3) +
  labs(title = "Box Plot with Outliers", y = "Staff per 10 Residents") +
  theme_minimal() +
  theme(axis.text.x = element_blank())

grid.arrange(p1, p2, ncol = 2)
```

## Python
```{python}
#| eval: true
import matplotlib.pyplot as plt

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

ax1.hist(care_homes['staff_per_10'], bins=40, density=True, 
         alpha=0.7, color='lightblue', edgecolor='black')
care_homes['staff_per_10'].plot(kind='density', ax=ax1, color='darkblue', linewidth=2)
ax1.set_xlabel('Staff per 10 Residents')
ax1.set_ylabel('Density')
ax1.set_title('Distribution of Staffing Ratios')

ax2.boxplot(care_homes['staff_per_10'])
ax2.set_ylabel('Staff per 10 Residents')
ax2.set_title('Box Plot with Outliers')

plt.tight_layout()
plt.show()
```
:::

**Observations**: Right-skewed with extreme values in both tails.

---

## üîç Step 3: Apply Detection Methods

::: {.panel-tabset}
## R
```{r}
#| eval: true
# Z-score
care_homes$z_score <- scale(care_homes$staff_per_10)[,1]
care_homes$outlier_z <- abs(care_homes$z_score) > 2.5

# Modified Z-score
median_val <- median(care_homes$staff_per_10)
mad_val <- mad(care_homes$staff_per_10)
care_homes$modified_z <- 0.6745 * (care_homes$staff_per_10 - median_val) / mad_val
care_homes$outlier_modz <- abs(care_homes$modified_z) > 3.5

# IQR
Q1 <- quantile(care_homes$staff_per_10, 0.25)
Q3 <- quantile(care_homes$staff_per_10, 0.75)
IQR_val <- IQR(care_homes$staff_per_10)
care_homes$outlier_iqr <- care_homes$staff_per_10 < (Q1 - 1.5*IQR_val) | 
                          care_homes$staff_per_10 > (Q3 + 1.5*IQR_val)

care_homes$num_flags <- care_homes$outlier_z + care_homes$outlier_modz + care_homes$outlier_iqr

cat("DETECTION RESULTS:\n")
cat("Z-score:", sum(care_homes$outlier_z), "outliers\n")
cat("Modified Z:", sum(care_homes$outlier_modz), "outliers\n")
cat("IQR:", sum(care_homes$outlier_iqr), "outliers\n")
```

## Python
```{python}
#| eval: true
from scipy import stats
from scipy.stats import median_abs_deviation

care_homes['z_score'] = stats.zscore(care_homes['staff_per_10'])
care_homes['outlier_z'] = abs(care_homes['z_score']) > 2.5

median_val = care_homes['staff_per_10'].median()
mad_val = median_abs_deviation(care_homes['staff_per_10'])
care_homes['modified_z'] = 0.6745 * (care_homes['staff_per_10'] - median_val) / mad_val
care_homes['outlier_modz'] = abs(care_homes['modified_z']) > 3.5

Q1 = care_homes['staff_per_10'].quantile(0.25)
Q3 = care_homes['staff_per_10'].quantile(0.75)
IQR_val = Q3 - Q1
care_homes['outlier_iqr'] = ((care_homes['staff_per_10'] < Q1 - 1.5*IQR_val) | 
                             (care_homes['staff_per_10'] > Q3 + 1.5*IQR_val))

care_homes['num_flags'] = (care_homes['outlier_z'].astype(int) + 
                           care_homes['outlier_modz'].astype(int) + 
                           care_homes['outlier_iqr'].astype(int))

print("DETECTION RESULTS:")
print(f"Z-score: {care_homes['outlier_z'].sum()} outliers")
print(f"Modified Z: {care_homes['outlier_modz'].sum()} outliers")
print(f"IQR: {care_homes['outlier_iqr'].sum()} outliers")
```
:::

---

## üîç Step 4: Compare Methods

::: {.panel-tabset}
## R
```{r}
#| eval: true
# Filter and sort without dplyr
high_priority <- care_homes[care_homes$num_flags >= 2, 
                            c("home_id", "staff_per_10", "z_score", "num_flags", 
                              "care_type", "beds", "cqc_rating")]
high_priority <- high_priority[order(-abs(high_priority$z_score)), ]

cat("HIGH PRIORITY (2+ methods):\n\n")
print(head(high_priority, 15), row.names = FALSE)
```

## Python
```{python}
#| eval: true
high_priority = care_homes[care_homes['num_flags'] >= 2][
    ['home_id', 'staff_per_10', 'z_score', 'num_flags', 'care_type', 'beds', 'cqc_rating']
].sort_values('z_score', key=abs, ascending=False)

print("HIGH PRIORITY (2+ methods):\n")
print(high_priority.head(15).to_string(index=False))
```
:::

---

## üîç Step 5: Investigation and Treatment

::: {.panel-tabset}
## R
```{r}
#| eval: true
# Base R classification
investigation <- high_priority
investigation$finding <- ifelse(
  investigation$staff_per_10 < 0.2, "Data error: Decimal missing",
  ifelse(investigation$staff_per_10 > 9, "Data error: Wrong unit",
  ifelse(investigation$care_type == "Dementia" & investigation$staff_per_10 > 4.5, 
         "Genuine: Specialist unit",
  ifelse(investigation$staff_per_10 < 1.8 & investigation$cqc_rating == "Inadequate",
         "Concern: Known issues",
  ifelse(investigation$staff_per_10 > 5 & investigation$beds < 30, 
         "Small home variation", "Requires investigation")))))

investigation$action <- ifelse(
  grepl("Data error", investigation$finding), "Exclude",
  ifelse(grepl("Concern", investigation$finding), "Flag for inspection",
         "Keep with note"))

cat("INVESTIGATION SUMMARY:\n\n")
table(investigation$action)
```

## Python
```{python}
#| eval: true
def classify_finding(row):
    if row['staff_per_10'] < 0.2:
        return "Data error: Decimal missing"
    elif row['staff_per_10'] > 9:
        return "Data error: Wrong unit"
    elif row['care_type'] == "Dementia" and row['staff_per_10'] > 4.5:
        return "Genuine: Specialist unit"
    elif row['staff_per_10'] < 1.8 and row['cqc_rating'] == "Inadequate":
        return "Concern: Known issues"
    elif row['staff_per_10'] > 5 and row['beds'] < 30:
        return "Small home variation"
    return "Requires investigation"

def classify_action(finding):
    if "Data error" in finding:
        return "Exclude"
    elif "Concern" in finding:
        return "Flag for inspection"
    return "Keep with note"

investigation = high_priority.copy()
investigation['finding'] = investigation.apply(classify_finding, axis=1)
investigation['action'] = investigation['finding'].apply(classify_action)

print("INVESTIGATION SUMMARY:\n")
print(investigation['action'].value_counts())
```
:::

---

## üìä Final Output

::: {.panel-tabset}
## R
```{r}
#| eval: true
# Merge investigation results (base R)
invest_subset <- investigation[, c("home_id", "finding", "action")]
care_homes_final <- merge(care_homes, invest_subset, by = "home_id", all.x = TRUE)
care_homes_final$exclude <- !is.na(care_homes_final$action) & 
                            care_homes_final$action == "Exclude"

care_homes_clean <- care_homes_final[is.na(care_homes_final$exclude) | 
                                     !care_homes_final$exclude, ]

cat("FINAL SUMMARY:\n")
cat("Total homes:", nrow(care_homes_final), "\n")
cat("Excluded:", sum(care_homes_final$exclude, na.rm = TRUE), "\n")
cat("Clean dataset:", nrow(care_homes_clean), "\n")
cat("Mean (clean):", round(mean(care_homes_clean$staff_per_10), 2), "\n")
```

## Python
```{python}
#| eval: true
care_homes_final = care_homes.merge(
    investigation[['home_id', 'finding', 'action']], on='home_id', how='left'
)
care_homes_final['exclude'] = (care_homes_final['action'] == 'Exclude')

care_homes_clean = care_homes_final[~care_homes_final['exclude'].fillna(False)]

print("FINAL SUMMARY:")
print(f"Total homes: {len(care_homes_final)}")
print(f"Excluded: {care_homes_final['exclude'].sum()}")
print(f"Clean dataset: {len(care_homes_clean)}")
print(f"Mean (clean): {care_homes_clean['staff_per_10'].mean():.2f}")
```
:::

---

## üìù Key Takeaways

### What We Learned

1. **Multiple methods essential**: Agreement across methods prioritizes investigation
2. **Investigation is crucial**: Detection flags candidates, investigation determines action
3. **Document everything**: Record findings and justifications for QA
4. **Context matters**: Specialist units and small homes legitimately differ
5. **Data quality**: Many "outliers" were simply data entry errors

### Recommendations for Inspection Team

**Immediate action required**:
- Homes flagged with genuine staffing concerns
- Data quality issues to be corrected by providers

**Monitor**:
- Small homes with higher variation (natural)
- Specialist units with elevated staffing (expected)

### QA Documentation

Complete investigation log created including:
- Detection method results
- Investigation findings for each flagged home
- Treatment decisions with justification
- Final clean dataset with exclusion flags

---

## üí° Practical Tips

1. **Always visualize first**: Understand distribution before applying methods
2. **Use multiple methods**: Look for consensus, not single-method results
3. **Prioritize investigation**: Focus on homes flagged by 2+ methods
4. **Contact providers**: Many "outliers" are simple data entry errors
5. **Consider context**: Small providers and specialists naturally vary
6. **Document thoroughly**: Investigation log essential for QA and defensibility

---

## üîó Related Resources

- **Chapter 15**: Outlier Detection and Treatment (@sec-outlier-methods)
- **Chapter 7**: Unusual Observations (conceptual foundations) (@sec-unusual-observations)
- **Chapter 10**: QA Principles (@sec-qa-principles)
